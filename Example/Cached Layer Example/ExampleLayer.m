//
//  ExampleLayer.m
//  Cached Layer Example
//
//  Created by Johan Nordberg on 2012-07-11.
//  Copyright (c) 2012 FFFF00 Agents AB. All rights reserved.
//

#import "ExampleLayer.h"

@implementation ExampleLayer

@dynamic hue;

+ (BOOL)needsDisplayForKey:(NSString *)key {
  if ([key isEqualToString:@"hue"]) {
    return YES;
  }
  return [super needsDisplayForKey:key];
}

- (NSString *)formattedValueForKey:(NSString *)key {
  if ([key isEqualToString:@"hue"]) {
    return [NSString stringWithFormat:@"%d", (int)([self currentHue] * kExampleLayerNumStates)];
  } else {
    return nil;
  }
}

- (float)currentHue {
  if (self.presentationLayer != nil) {
    return ((ExampleLayer *)self.presentationLayer).hue;
  } else {
    return self.hue;
  }
}

// NOTE: this is an overly complex draw to test performance
//       please do not take this as an example of how to draw UI elements :)
- (void)drawInContext:(CGContextRef)context {
  // drawing code generated by paintcode
  UIGraphicsPushContext(context);
  
  //// General Declarations
  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
  
  //// Color Declarations
  //UIColor* color = [UIColor colorWithRed: 0.89 green: 0.27 blue: 0.62 alpha: 1];
  UIColor *color = [UIColor colorWithHue:[self currentHue] saturation:0.809 brightness:0.886 alpha:1.000];
  CGFloat colorRGBA[4];
  [color getRed: &colorRGBA[0] green: &colorRGBA[1] blue: &colorRGBA[2] alpha: &colorRGBA[3]];
  
  CGFloat colorHSBA[4];
  [color getHue: &colorHSBA[0] saturation: &colorHSBA[1] brightness: &colorHSBA[2] alpha: &colorHSBA[3]];
  
  UIColor* bggColor = [UIColor colorWithHue: colorHSBA[0] saturation: colorHSBA[1] brightness: 0.05 alpha: colorHSBA[3]];
  CGFloat bggColorRGBA[4];
  [bggColor getRed: &bggColorRGBA[0] green: &bggColorRGBA[1] blue: &bggColorRGBA[2] alpha: &bggColorRGBA[3]];
  
  UIColor* bggColor2 = [UIColor colorWithRed: (bggColorRGBA[0] * 0.85 + 0.15) green: (bggColorRGBA[1] * 0.85 + 0.15) blue: (bggColorRGBA[2] * 0.85 + 0.15) alpha: (bggColorRGBA[3] * 0.85 + 0.15)];
  UIColor* b = [UIColor colorWithRed: (colorRGBA[0] * 0.5) green: (colorRGBA[1] * 0.5) blue: (colorRGBA[2] * 0.5) alpha: (colorRGBA[3] * 0.5 + 0.5)];
  UIColor* s1 = [color colorWithAlphaComponent: 0.3];
  UIColor* g2 = [UIColor colorWithRed: (colorRGBA[0] * 0.2) green: (colorRGBA[1] * 0.2) blue: (colorRGBA[2] * 0.2) alpha: (colorRGBA[3] * 0.2 + 0.8)];
  UIColor* s2 = [g2 colorWithAlphaComponent: 0.5];
  
  //// Gradient Declarations
  NSArray* gradColors = [NSArray arrayWithObjects:
                         (id)color.CGColor,
                         (id)g2.CGColor, nil];
  CGFloat gradLocations[] = {0, 1};
  CGGradientRef grad = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)gradColors, gradLocations);
  NSArray* bggColors = [NSArray arrayWithObjects:
                        (id)bggColor2.CGColor,
                        (id)bggColor.CGColor, nil];
  CGFloat bggLocations[] = {0, 1};
  CGGradientRef bgg = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)bggColors, bggLocations);
  
  //// Shadow Declarations
  UIColor* shadow = s2;
  CGSize shadowOffset = CGSizeMake(0, -0);
  CGFloat shadowBlurRadius = 20;
  UIColor* shadow2 = s1;
  CGSize shadow2Offset = CGSizeMake(0, -0);
  CGFloat shadow2BlurRadius = 10;
  
  //// Frames
  CGRect frame = CGRectMake(0, 0, 320, 480);
  
  //// Abstracted Graphic Attributes
  NSString* textContent = [self formattedValueForKey:@"hue"];

  
  //// bg Drawing
  CGRect bgRect = CGRectMake(CGRectGetMinX(frame) + 0, CGRectGetMinY(frame) + 0, 320, 480);
  UIBezierPath* bgPath = [UIBezierPath bezierPathWithRect: bgRect];
  CGContextSaveGState(context);
  [bgPath addClip];
  CGContextDrawLinearGradient(context, bgg,
                              CGPointMake(CGRectGetMidX(bgRect), CGRectGetMinY(bgRect)),
                              CGPointMake(CGRectGetMidX(bgRect), CGRectGetMaxY(bgRect)),
                              0);
  CGContextRestoreGState(context);
  
  
  
  //// text Drawing
  CGRect textRect = CGRectMake(CGRectGetMinX(frame) + floor((CGRectGetWidth(frame) - 98) * 0.5), CGRectGetMinY(frame) + floor((CGRectGetHeight(frame) - 34) * 0.5), 98, 34);
  CGContextSaveGState(context);
  CGContextSetShadowWithColor(context, shadowOffset, shadowBlurRadius, shadow.CGColor);
  [color setFill];
  [textContent drawInRect: textRect withFont: [UIFont fontWithName: @"Thonburi-Bold" size: 23] lineBreakMode: UILineBreakModeWordWrap alignment: UITextAlignmentCenter];
  CGContextRestoreGState(context);
  
  
  
  //// shape Drawing
  UIBezierPath* shapePath = [UIBezierPath bezierPath];
  [shapePath moveToPoint: CGPointMake(CGRectGetMinX(frame) + 189.06, CGRectGetMinY(frame) + 151.17)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 241.92, CGRectGetMinY(frame) + 128.66)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 235.27, CGRectGetMinY(frame) + 182.47)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 274, CGRectGetMinY(frame) + 189.77)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 208.53, CGRectGetMinY(frame) + 225)];
  [shapePath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 194.89, CGRectGetMinY(frame) + 200.06) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 206.99, CGRectGetMinY(frame) + 215.87) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 202.44, CGRectGetMinY(frame) + 207.1)];
  [shapePath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 126.11, CGRectGetMinY(frame) + 200.06) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 175.9, CGRectGetMinY(frame) + 182.36) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 145.1, CGRectGetMinY(frame) + 182.36)];
  [shapePath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 112.46, CGRectGetMinY(frame) + 225) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 118.56, CGRectGetMinY(frame) + 207.1) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 114.01, CGRectGetMinY(frame) + 215.87)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 47, CGRectGetMinY(frame) + 189.77)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 85.73, CGRectGetMinY(frame) + 182.47)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 79.08, CGRectGetMinY(frame) + 128.66)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 131.94, CGRectGetMinY(frame) + 151.17)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 160.5, CGRectGetMinY(frame) + 104)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 189.06, CGRectGetMinY(frame) + 151.17)];
  [shapePath closePath];
  [shapePath moveToPoint: CGPointMake(CGRectGetMinX(frame) + 126.11, CGRectGetMinY(frame) + 277.97)];
  [shapePath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 194.89, CGRectGetMinY(frame) + 277.97) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 145.1, CGRectGetMinY(frame) + 295.67) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 175.9, CGRectGetMinY(frame) + 295.67)];
  [shapePath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 208.1, CGRectGetMinY(frame) + 255.26) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 201.83, CGRectGetMinY(frame) + 271.51) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 206.23, CGRectGetMinY(frame) + 263.58)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 273.32, CGRectGetMinY(frame) + 290.36)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 235.27, CGRectGetMinY(frame) + 297.53)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 241.92, CGRectGetMinY(frame) + 351.34)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 189.06, CGRectGetMinY(frame) + 328.83)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 160.5, CGRectGetMinY(frame) + 376)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 131.94, CGRectGetMinY(frame) + 328.83)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 79.08, CGRectGetMinY(frame) + 351.34)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 85.73, CGRectGetMinY(frame) + 297.53)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 47.68, CGRectGetMinY(frame) + 290.36)];
  [shapePath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 112.91, CGRectGetMinY(frame) + 255.26)];
  [shapePath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 126.11, CGRectGetMinY(frame) + 277.97) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 114.77, CGRectGetMinY(frame) + 263.58) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 119.17, CGRectGetMinY(frame) + 271.51)];
  [shapePath closePath];
  CGContextSaveGState(context);
  CGContextSetShadowWithColor(context, shadowOffset, shadowBlurRadius, shadow.CGColor);
  CGContextBeginTransparencyLayer(context, NULL);
  [shapePath addClip];
  CGRect shapeBounds = shapePath.bounds;
  CGFloat shapeResizeRatio = MIN(CGRectGetWidth(shapeBounds) / 227, CGRectGetHeight(shapeBounds) / 272);
  CGContextDrawRadialGradient(context, grad,
                              CGPointMake(CGRectGetMidX(shapeBounds) + 0 * shapeResizeRatio, CGRectGetMidY(shapeBounds) + -0 * shapeResizeRatio), 48.22 * shapeResizeRatio,
                              CGPointMake(CGRectGetMidX(shapeBounds) + 0 * shapeResizeRatio, CGRectGetMidY(shapeBounds) + -0 * shapeResizeRatio), 163.33 * shapeResizeRatio,
                              kCGGradientDrawsBeforeStartLocation | kCGGradientDrawsAfterEndLocation);
  CGContextEndTransparencyLayer(context);
  
  ////// shape Inner Shadow
  CGRect shapeBorderRect = CGRectInset([shapePath bounds], -shadow2BlurRadius, -shadow2BlurRadius);
  shapeBorderRect = CGRectOffset(shapeBorderRect, -shadow2Offset.width, -shadow2Offset.height);
  shapeBorderRect = CGRectInset(CGRectUnion(shapeBorderRect, [shapePath bounds]), -1, -1);
  
  UIBezierPath* shapeNegativePath = [UIBezierPath bezierPathWithRect: shapeBorderRect];
  [shapeNegativePath appendPath: shapePath];
  shapeNegativePath.usesEvenOddFillRule = YES;
  
  CGContextSaveGState(context);
  {
    CGFloat xOffset = shadow2Offset.width + round(shapeBorderRect.size.width);
    CGFloat yOffset = shadow2Offset.height;
    CGContextSetShadowWithColor(context,
                                CGSizeMake(xOffset + copysign(0.1, xOffset), yOffset + copysign(0.1, yOffset)),
                                shadow2BlurRadius,
                                shadow2.CGColor);
    
    [shapePath addClip];
    CGAffineTransform transform = CGAffineTransformMakeTranslation(-round(shapeBorderRect.size.width), 0);
    [shapeNegativePath applyTransform: transform];
    [[UIColor grayColor] setFill];
    [shapeNegativePath fill];
  }
  CGContextRestoreGState(context);
  
  CGContextRestoreGState(context);
  
  [b setStroke];
  shapePath.lineWidth = 0.5;
  [shapePath stroke];
  
  //// Cleanup
  CGGradientRelease(grad);
  CGGradientRelease(bgg);
  CGColorSpaceRelease(colorSpace);
  UIGraphicsPopContext();
}

@end
